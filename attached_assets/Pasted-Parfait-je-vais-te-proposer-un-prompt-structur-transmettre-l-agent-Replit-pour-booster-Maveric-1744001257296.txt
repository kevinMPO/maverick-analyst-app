Parfait, je vais te proposer un prompt structurÃ© Ã  transmettre Ã  l'agent Replit pour booster Maverick. Je vais inclure un plan Ã©tape par Ã©tape avec les APIs Ã  appeler, le type de donnÃ©es attendues, et comment enrichir l'analyse IA pour qu'elle devienne bluffante.
Je reviens vers toi avec un plan prÃ©cis dans quelques instants.

# Plan dâ€™implÃ©mentation de lâ€™agent IA **Maverick** ğŸ”ğŸ’¼

## Architecture gÃ©nÃ©rale de la solution  
Lâ€™agent **Maverick** est composÃ© de quatre modules Python interconnectÃ©s, chacun responsable dâ€™une source de donnÃ©es ou dâ€™une fonction spÃ©cifiqueÂ :  

- **`societeinfo.py`** â€“ RÃ©cupÃ¨re les donnÃ©es lÃ©gales et dâ€™identification de lâ€™entreprise (nom, SIREN, forme juridique, adresse, etc.) ainsi que quelques donnÃ©es financiÃ¨res de base via lâ€™API SocieteInfo.  
- **`scores.py`** â€“ Interroge lâ€™API **Scores & DÃ©cisions** pour obtenir des indicateurs financiers dÃ©taillÃ©s (ex: chiffres dâ€™affaires, rÃ©sultats, capitaux propres) et le **score de solvabilitÃ©** ou de risque de lâ€™entreprise.  
- **`news.py`** â€“ AgrÃ¨ge les actualitÃ©s rÃ©centes concernant lâ€™entrepriseÂ : Ã©vÃ©nements stratÃ©giques via lâ€™API SocieteInfo *Get Events* et Ã©ventuellement recherches web (Bing API ou SerpAPI) pour complÃ©ter par des news publiques.  
- **`agent.py`** â€“ Orchestrateur principal qui appelle les trois sources ci-dessus, formate toutes les informations collectÃ©es dans un **prompt** structurÃ©, puis envoie ce prompt au modÃ¨le LLM (LLaMA-4 Maverick via lâ€™API Replicate) pour gÃ©nÃ©rer la **synthÃ¨se finale en Markdown**.  

Cette architecture modulaire permet de sÃ©parer clairement les responsabilitÃ©s et de faciliter la maintenance du code.

## IntÃ©gration des sources de donnÃ©es ğŸ”—

### 1. DonnÃ©es lÃ©gales et identification â€“ *SocieteInfo API*  
Le module `societeinfo.py` utilise lâ€™endpoint **Get Company** de SocieteInfo pour obtenir les informations lÃ©gales de lâ€™entreprise. Lâ€™appel se fait en HTTP GET sur lâ€™URL suivant (en fournissant le SIREN)Â :  

```
GET https://societeinfo.com/app/rest/api/v2/company.json/<SIREN>?key=<VOTRE_API_KEY>
```  

**Champs JSON clÃ©s Ã  exploiter** dans la rÃ©ponse:  
- `organization.name` â€“ DÃ©nomination de lâ€™entreprise (raison sociale).  
- `organization.registration_number` â€“ SIREN de lâ€™entreprise.  
- `organization.legal.name` â€“ Forme juridique (e.g. â€œSARLâ€, â€œSASUâ€¦â€).  
- `organization.creation_date` â€“ Date de crÃ©ation de lâ€™entreprise.  
- `organization.capital` â€“ Capital social dÃ©clarÃ© (â‚¬).  
- `organization.address` â€“ Adresse du siÃ¨ge (street, city, code postalâ€¦).  
- `organization.risk.risk_level_description` â€“ Description du niveau de risque lÃ©gal (**ex.** *â€œPas de risque identifiÃ©â€*).  
- `result.financials.last_sales` â€“ Dernier chiffre dâ€™affaires connu.  
- `result.financials.last_profit` â€“ Dernier rÃ©sultat net connu.  
- `result.financials.last_staff` â€“ Effectif salariÃ© (dernier effectif dÃ©clarÃ©).  

Le code ci-dessous illustre lâ€™appel Ã  lâ€™API SocieteInfo et lâ€™extraction des champs souhaitÃ©sÂ :  

```python
import requests, os

API_KEY = os.getenv("SOCIETEINFO_API_KEY")
def get_company_data(siren):
    url = f"https://societeinfo.com/app/rest/api/v2/company.json/{siren}"
    params = {"key": API_KEY}
    res = requests.get(url, params=params, timeout=5)
    data = res.json()
    if not data.get("success"):
        return None  # GÃ©rer les erreurs (404, 401, etc.)
    org = data["result"]["organization"]
    fin = data["result"].get("financials", {})
    company_info = {
        "nom": org.get("name"),
        "siren": org.get("registration_number"),
        "forme_juridique": org.get("legal", {}).get("name"),
        "creation": org.get("creation_date"),
        "capital_social": org.get("capital"),
        "adresse": f"{org.get('address', {}).get('street', '')}, "
                   f"{org.get('address', {}).get('postal_code', '')} {org.get('address', {}).get('city', '')}",
        "ca": fin.get("last_sales"),         # Chiffre d'affaires
        "resultat": fin.get("last_profit"),  # RÃ©sultat net
        "effectif": fin.get("last_staff"),
        "risque_legale": org.get("risk", {}).get("risk_level_description")
    }
    return company_info
```  

*RemarqueÂ :* Le SIREN peut Ãªtre fourni directement. SocieteInfo permet Ã©galement une recherche par nom (`q=`) si on ne possÃ¨de pas le SIREN, mais ici on part du SIREN. Il faut inclure la clÃ© API (`key`) dans les paramÃ¨tres de requÃªte. Il est conseillÃ© de stocker cette clÃ© dans une variable dâ€™environnement pour ne pas lâ€™exposer dans le code (comme illustrÃ© avec `os.getenv`).  

### 2. DonnÃ©es financiÃ¨res & score de solvabilitÃ© â€“ *Scores & DÃ©cisions API*  
Le module `scores.py` va complÃ©ter les informations financiÃ¨res via le service **Scores & DÃ©cisions**. Cet API (endpoint `getIndiScore`) fournit un **scoring financier** et des indicateurs clÃ©s sur la santÃ© de lâ€™entreprise. Lâ€™appel se fait aussi en GET, avec authentification Basic (identifiants fournis par Scores & DÃ©cisions)Â :  

```
GET https://ws.scores-decisions.com/api/V1/service/entreprise/act/getIndiScore/<SIREN>
Authorization: Basic <token_base64>
Accept: application/json
```  

**Champs JSON clÃ©s attendus** (exemple typique, Ã  adapter selon la structure rÃ©elle renvoyÃ©e)Â :  
- `score` ou `notation` â€“ Score de solvabilitÃ© de lâ€™entreprise (par ex. une note sur 10 ou une classe de risque).  
- `risk_level` â€“ Niveau de risque chiffrÃ© ou catÃ©gorisÃ© (faible, modÃ©rÃ©, Ã©levÃ©).  
- `failure_probability` â€“ ProbabilitÃ© de dÃ©faillance Ã  un an (si fourni).  
- `recommended_credit_limit` â€“ Encours crÃ©dit recommandÃ© (montant â‚¬ maximal conseillÃ© pour les crÃ©ances).  
- `financials` â€“ DÃ©tails financiers rÃ©cents, par ex: 
  - `turnover` (ou `ca`) â€“ Chiffre dâ€™affaires dernier exercice.  
  - `net_income` (ou `resultat_net`) â€“ RÃ©sultat net dernier exercice.  
  - `equity` (ou `capitaux_propres`) â€“ Capitaux propres.  
  - `debt` â€“ Endettement total ou ratio dâ€™endettement.  
- `payment_incidents` â€“ Indicateurs dâ€™incidents de paiement (par ex. nombre de procÃ©dures, incidents bancaires, sâ€™il y en a).  

Un exemple de code pour appeler lâ€™API S&D et parser la rÃ©ponseÂ :  

```python
import requests, os
from base64 import b64encode

SD_USER = os.getenv("SD_USER")       # Identifiant API Scores & DÃ©cisions
SD_PASS = os.getenv("SD_PASS")       # Mot de passe API
AUTH_TOKEN = b64encode(f"{SD_USER}:{SD_PASS}".encode()).decode()  # encodage Basic Auth

def get_scores_data(siren):
    url = f"https://ws.scores-decisions.com/api/V1/service/entreprise/act/getIndiScore/{siren}"
    headers = {"Authorization": f"Basic {AUTH_TOKEN}", "Accept": "application/json"}
    res = requests.get(url, headers=headers, timeout=5)
    res.raise_for_status()
    data = res.json()
    # Extraction des champs principaux (en adaptant aux clÃ©s exactes de lâ€™API)
    scores_info = {
        "score": data.get("score"),  # score chiffrÃ© ou classe
        "risque_financier": data.get("risk_level") or data.get("risk"),  
        "probabilite_defaillance": data.get("failure_probability"),
        "limite_credit": data.get("recommended_credit_limit"),
        "ca_dernier_ex": data.get("financials", {}).get("turnover"),
        "resultat_net": data.get("financials", {}).get("net_income"),
        "capitaux_propres": data.get("financials", {}).get("equity"),
    }
    return scores_info
```  

Ici aussi, on rÃ©cupÃ¨re les identifiants API depuis des variables dâ€™environnement. Le dictionnaire `scores_info` est fusionnÃ© avec les donnÃ©es de `societeinfo.py` pour former un tableau de bord complet de lâ€™entreprise. Par exemple, on peut combiner ainsi :  

```python
company_data = get_company_data(siren)
scores_data = get_scores_data(siren)
if company_data and scores_data:
    company_data.update(scores_data)
```  

DÃ¨s lors, `company_data` contiendra tous les Ã©lÃ©ments lÃ©gaux et financiers (dont le **score** S&D et les **capitaux propres** si disponibles) Ã  injecter dans le prompt.  

### 3. Ã‰vÃ©nements stratÃ©giques rÃ©cents â€“ *SocieteInfo Events API*  
Pour enrichir lâ€™analyse stratÃ©gique, le module `news.py` peut rÃ©cupÃ©rer les **Ã©vÃ©nements rÃ©cents** de lâ€™entreprise via lâ€™endpoint *Get Events* de SocieteInfo. Cet appel renvoie les actualitÃ©s majeures (levÃ©es de fonds, acquisitions, nominations, etc.) liÃ©es Ã  lâ€™entreprise, Ã  partir de sources mÃ©dias ou communiquÃ©s. RequÃªte HTTP typiqueÂ :  

```
GET https://societeinfo.com/app/rest/api/v2/events.json/<SIREN>?key=<API_KEY>
```  

**Champs JSON importants** dans la section `events` du rÃ©sultat :  
- `theme` â€“ CatÃ©gorie de lâ€™Ã©vÃ©nement (ex: â€œDÃ©veloppementâ€, â€œFusion, acquisitionâ€¦â€, â€œRecrutementâ€).  
- `sub_theme_label` â€“ PrÃ©cision sur le type dâ€™Ã©vÃ©nement (ex: â€œInnovation, nouveaux contratsâ€, â€œLevÃ©e de fondsâ€, â€œNominationâ€, etc.).  
- `news_summary` â€“ RÃ©sumÃ© de lâ€™actualitÃ© en quelques phrases.  
- `article_title` â€“ Titre de lâ€™article/source, pouvant servir pour rÃ©sumer.  
- `news_delivery_date` â€“ Date de la collecte de lâ€™info (souvent proche de la date de publication).  

Le code suivant montre comment appeler lâ€™API et extraire quelques Ã©vÃ©nements :  

```python
def get_recent_events(siren):
    url = f"https://societeinfo.com/app/rest/api/v2/events.json/{siren}"
    params = {"key": API_KEY}
    res = requests.get(url, params=params, timeout=5)
    data = res.json()
    events_list = []
    for ev in data.get("result", {}).get("events", [])[:3]:  # on limite aux 3 plus rÃ©cents
        date = ev.get("news_delivery_date")
        summary = ev.get("news_summary") or ev.get("article_title")
        theme = ev.get("sub_theme_label")
        if date and summary:
            events_list.append(f"{date} â€“ {theme}: {summary}")
    return events_list
```  

On rÃ©cupÃ¨re ici jusquâ€™Ã  3 Ã©vÃ©nements rÃ©cents, en formatant chaque Ã©lÃ©ment avec la date, le thÃ¨me et un court rÃ©sumÃ©. Ces informations seront intÃ©grÃ©es au prompt pour que lâ€™IA en tienne compte dans son analyse (*ex:* mention dâ€™une levÃ©e de fonds rÃ©cente, qui peut influencer lâ€™Ã©valuation du risque ou des opportunitÃ©s).  

### 4. (Optionnel) Recherches web dâ€™actualitÃ©s â€“ *Bing News API / SerpAPI*  
En complÃ©ment des Ã©vÃ©nements fournis par SocieteInfo, il est envisageable dâ€™effectuer une recherche dâ€™actualitÃ© sur le Web pour capter dâ€™autres informations (articles de presse rÃ©cents, communiquÃ©s, etc.). Ceci est optionnel car souvent les Ã©vÃ©nements clÃ©s sont dÃ©jÃ  couverts par SocieteInfo. Si on souhaite lâ€™ajouterÂ :  

- Utiliser par exemple **Bing News Search API** ou **SerpAPI** en passant le nom de lâ€™entreprise en requÃªte.  
- Filtrer les rÃ©sultats par date rÃ©cente et pertinence.  
- Extraire le titre et un bref extrait des 1 ou 2 articles les plus pertinents non dÃ©jÃ  couverts.  

*Exemple (Bing Search via requÃªte HTTP)*Â :  

```python
BING_API_KEY = os.getenv("BING_API_KEY")
def search_news(company_name):
    url = "https://api.bing.microsoft.com/v7.0/news/search"
    params = {"q": company_name, "mkt": "fr-FR", "sortBy": "Date"}
    headers = {"Ocp-Apim-Subscription-Key": BING_API_KEY}
    res = requests.get(url, params=params, headers=headers)
    results = res.json().get("value", [])[:2]
    news_snippets = [f"{item['name']} â€“ {item['description']}" for item in results]
    return news_snippets
```  

On pourrait fusionner ces rÃ©sultats avec ceux de `get_recent_events` pour avoir une vision complÃ¨te des derniÃ¨res nouvelles de lâ€™entreprise. **Attention** toutefois Ã  ne pas surcharger le prompt : sÃ©lectionner les informations vraiment pertinentes pour la synthÃ¨se (par exemple, un fait marquant comme une acquisition importante ou un changement de direction).  

## Construction du prompt et gÃ©nÃ©ration de la synthÃ¨se ğŸ“‹ğŸ¤–

Une fois toutes les donnÃ©es collectÃ©es, le module `agent.py` va formater le **prompt** Ã  envoyer au modÃ¨le LLaMA-4 Maverick (via lâ€™API Replicate). Lâ€™objectif est de fournir Ã  lâ€™IA un contexte complet et de demander une synthÃ¨se structurÃ©e, **dans un style professionnel, percutant et orientÃ© dÃ©cision**. 

### Composition du prompt  
Le prompt peut Ãªtre construit sous forme de *bullet points* listant les informations factuelles, suivi dâ€™une consigne pour la recommandation. Par exempleÂ :  

```python
company = company_data  # dict combinÃ© de societeinfo, scores & events
events_text = "\\n".join([f"- {ev}" for ev in company.get('evenements', [])])

prompt = f"""
Tu es un analyste financier IA. Voici les donnÃ©es dâ€™une entrepriseÂ :

- **Nom** : {company['nom']}
- **SIREN** : {company['siren']}
- **Forme juridique** : {company['forme_juridique']}
- **AnciennetÃ©** : {company['creation']} (date de crÃ©ation)
- **Chiffre dâ€™affaires** : {company['ca']} â‚¬
- **RÃ©sultat net** : {company['resultat']} â‚¬
- **Capitaux propres** : {company['capitaux_propres']} â‚¬
- **Score de solvabilitÃ© (Scores & DÃ©cisions)** : {company['score']} ({company['risque_financier']})
- **Ã‰vÃ©nements rÃ©cents** :
{events_text if events_text else '- RAS'}

Analyse ces informations et fournis une synthÃ¨se **structurÃ©e en Markdown** avec :  
- Un aperÃ§u du profil et de la santÃ© financiÃ¨re de lâ€™entreprise  
- Une Ã©valuation du **risque crÃ©dit** (faible, moyen ou Ã©levÃ©)  
- Un conseil sur le **dÃ©lai de paiement** Ã  accorder (immÃ©diat, 15j, 30j, 60j)  
- Dâ€™Ã©ventuelles **opportunitÃ©s stratÃ©giques** ou points dâ€™**alerte** Ã  noter  

Le ton doit Ãªtre professionnel, concis et percutant, adaptÃ© Ã  un directeur financier ou commercial. Utilise des Ã©mojis pour mettre en avant les points clÃ©s et des bullet points pour la lisibilitÃ©.
"""
```  

Quelques points importants dans ce prompt :  
- On liste dâ€™abord toutes les **donnÃ©es factuelles** collectÃ©es (profil de lâ€™entreprise, chiffres clÃ©s, scoreâ€¦). Cela donne du contexte au modÃ¨le.  
- On inclut les **Ã©vÃ©nements rÃ©cents** sous forme de liste Ã  puces (ou "RAS" = Rien Ã€ Signaler si aucun Ã©vÃ©nement notable) pour informer lâ€™IA des derniÃ¨res actualitÃ©s.  
- Ensuite, on **demande explicitement** la forme de la rÃ©ponse attendue : une synthÃ¨se structurÃ©e en Markdown, avec emojis et bullet points, et en couvrant les quatre volets demandÃ©s (profil financier, risque, paiement, opportunitÃ©s/alertes).  

Ainsi formÃ©, le prompt sera trÃ¨s dÃ©taillÃ©, ce qui aide le modÃ¨le Ã  produire une rÃ©ponse riche et contextuelle.  

### Appel du modÃ¨le LLaMA-4 via Replicate  
Avec le prompt prÃªt, `agent.py` utilise le client Replicate pour exÃ©cuter le modÃ¨le hÃ©bergÃ©. Par exemple, en Python avec la librairie `replicate` :  

```python
import replicate, os
REPLICATE_API_TOKEN = os.getenv("REPLICATE_API_TOKEN")
model = replicate.Client(api_token=REPLICATE_API_TOKEN).run(
    "meta/llama-4-maverick-instruct",  # Identifiant du modÃ¨le Maverick sur Replicate
    input={"prompt": prompt, "max_new_tokens": 500}
)
result_text = "".join(model)  # concatÃ¨ne les morceaux de sortie si nÃ©cessaire
```  

Ici on spÃ©cifie un `max_new_tokens` pour limiter la longueur de la rÃ©ponse. Le modÃ¨le devrait renvoyer du **Markdown** dÃ©jÃ  formatÃ© (puisquâ€™on lâ€™a instruit en ce sens). On obtient la synthÃ¨se finalisÃ©e dans `result_text`.  

Enfin, lâ€™agent peut afficher ou retourner ce `result_text` Ã  lâ€™utilisateur final. Sur **Replit**, on sâ€™assurera que le contenu Markdown rendu affiche bien les emojis et la mise en forme (gÃ©nÃ©ralement, Replit peut rendre le Markdown ou on peut le prÃ©visualiser).  

## Exemple de rendu enrichi ğŸ¯âœ¨

Supposons quâ€™on analyse lâ€™entreprise *ABC Tech* (SIREN fictif **012345678**). AprÃ¨s collecte des donnÃ©es, le modÃ¨le IA Maverick pourrait produire une synthÃ¨se comme celle-ci :  

ğŸš€ **Profil & Situation**  
- **ABC Tech** (SIREN 012345678) est une PME crÃ©Ã©e en 2015, spÃ©cialisÃ©e dans le dÃ©veloppement de logiciels SaaS. Lâ€™entreprise est en croissance, avec 50 employÃ©s et un siÃ¨ge Ã  Paris.  

ğŸ’° **Performance FinanciÃ¨re**  
- Chiffre dâ€™affaires 2022 : **5,2 Mâ‚¬** (en hausse de +10% vs 2021).  
- RÃ©sultat net 2022 : **+300 Kâ‚¬** (rentable, marge nette ~5.8%).  
- Capitaux propres : **1,2 Mâ‚¬**, ce qui tÃ©moigne dâ€™une structure financiÃ¨re saine (bonne solvabilitÃ©).  

âš–ï¸ **SolvabilitÃ© & Risque**  
- *Scores & DÃ©cisions* attribue un **score de solvabilitÃ© de 8/10**, indiquant un **risque faible** de dÃ©faut.  
- TrÃ©sorerie positive et aucune procÃ©dure collective en cours. Les indicateurs ne montrent pas dâ€™alerte majeure sur la solvabilitÃ©.  

ğŸ“° **Ã‰vÃ©nements RÃ©cents**  
- 2024-11-10 â€“ **LevÃ©e de fonds** : ABC Tech a levÃ© 2Â Mâ‚¬ pour accÃ©lÃ©rer son expansion Ã  lâ€™international.  
- 2024-06-05 â€“ **Partenariat** : Signature dâ€™un contrat stratÃ©gique avec le groupe XYZ pour la distribution de sa solution en Europe.  

âœ… **Recommandations**  
- **Risque crÃ©dit** : Faible. Vous pouvez accorder des conditions de paiement sans crainte excessive.  
- **DÃ©lai de paiement conseillÃ©** : *30 jours* fin de mois paraÃ®t appropriÃ© compte tenu de la soliditÃ© financiÃ¨re dâ€™ABC Tech.  
- **OpportunitÃ© stratÃ©gique** : Entreprise en plein essor â€“ renforcer le partenariat commercial pourrait Ãªtre bÃ©nÃ©fique.  
- **Points dâ€™alerte** : RAS notable, si ce nâ€™est Ã  surveiller la bonne utilisation des fonds levÃ©s (investissements en cours).  

---  

Dans cet exemple de rendu, on voit que la synthÃ¨se est structurÃ©e en sections avec des emojis en en-tÃªte, et utilise des bullet points pour les dÃ©tails. Le style est **clair, factuel et orientÃ© dÃ©cision**Â : un dirigeant peut en un coup dâ€™Å“il Ã©valuer le profil de lâ€™entreprise, son risque et les actions Ã  envisager. En combinant ainsi **donnÃ©es chiffrÃ©es** et **commentaires analytiques**, lâ€™agent Maverick fournit une aide Ã  la dÃ©cision percutante digne dâ€™un copilote *Top Gun* ğŸ›«ğŸ†. 